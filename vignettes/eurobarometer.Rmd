---
title: "Case Study: Working With Eurobarometer"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Case Study: Working With Eurobarometer}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(retroharmonize)
source(here("not_included", "daniel_env.R"))
```

In the [Afrobaromter Case Study](http://retroharmonize.satellitereport.com/articles/afrobarometer.html) we have shown how to merge two waves of a survey with a limited number of variables.  This workflow is not feasible with Eurobarometer on a PC or laptop, because there are too many large files to handle. 


```{r setup, message=FALSE}
library(retroharmonize)
library(dplyr)
```

We have created a helper function `subset_save_survey()` that programmatically reads in SPSS files, makes the necessary type conversion to `labelled_spss_survey()` without harmonization, and saves a small, subsetted `rds` file. Because this is a native R file, it is far more efficient to handle in the actual workflow.

```{r subsetting, eval=FALSE}
# To replicate the worklist, you need to have the SPSS file names 
# as a list, and you have to set up your own import and export path.

subset_save_surveys ( 
  survey_list = eb_metadata, 
  selection_name = "trust",
  import_path = gesis_dir, 
  export_path = "working" )

```

```{r import-display, eval=FALSE}
eurobarometer_waves <- file.path("working", dir("working"))
eb_waves <- read_surveys(eurobarometer_waves, .f='read_rds')
```

```{r import-here, echo=FALSE}
working_dir  <- here::here("working")
eurobarometer_waves <- file.path(working_dir, dir(working_dir))
eb_waves <- read_surveys(eurobarometer_waves, .f='read_rds')
```

We can review if the main descriptive metadata is correctly present with `document_waves()`.

```{r document-waves}
documented_waves <- document_waves (eb_waves) 
message("Wave list: ", attr(documented_waves, "original_list"))
print(documented_waves)
```


## Metadata map

Let's analyze the metadata of each survey file. 

```{r metadata}
eb_trust_metadata <- lapply ( X = eb_waves, FUN = metadata_create   )
eb_trust_metadata <- do.call(rbind, eb_trust_metadata)
```

```{r head}
head(eb_trust_metadata)
```

The value labels in this example are not too numerous.  The only variable that stands out is the `Can rely on` and `Cannot rely on` labelled variable. 

```{r valid-labels}
collect_val_labels(eb_trust_metadata)
```

And the labels that were marked by GESIS as missing values:

```{r missing-labels}
collect_na_labels(eb_trust_metadata)
```
## Harmonize the labels

For easier looping we adopt the `harmonize_values()` function with new default settings. It would be tempting to preserve the `rely` labels, but if we use the same numeric coding, it will lead to confusion. If you want to keep the difference of the two type of category labels, than the harmonization should be done in a two-step process. 

```{r specificfunction}
harmonize_eb_trust <- function(x) {
  label_list <- list(
    from = c("^tend\\snot", "^cannot", "^tend\\sto", "^can\\srely",
             "^dk", "^inap", "na"), 
    to = c("not_trust", "not_trust", "trust", "trust",
           "do_not_know", "inap", "inap"), 
    numeric_values = c(0,0,1,1, 99997,99999,99999)
  )

  harmonize_values(x, 
                   harmonize_labels = label_list, 
                   na_values = c("do_not_know"=99997,
                                 "declined"=99998,
                                 "inap"=99999)
  )
}
```

Let's see if things did work out fine:

```{r}
document_waves(eb_waves)
```

To review the harmonization on a single survey use `pull_survey()`. Before running our adapted harmonization function, we have this:


```{r, check}
test_trust <- pull_survey(eb_waves, filename = "ZA4414_trust.rds")
test_trust$trust_european_commission[1:16]
```
```{r}
harmonize_eb_trust(test_trust$trust_european_commission[1:16])
```

If you are satisfied with the results, run `harmonize_eb_trust``()` through the 9 survey waves. Whenever a variable is missing from a wave, it is filled up with `inapproriate` missing values.

## Harmonize waves

```{r harmonizewaves}
harmonized_eb_waves <- harmonize_waves ( waves = eb_waves, 
                                      .f = harmonize_eb_trust )
```

We cannot rely on `document_waves()` anymore, because the result is a single data frame. Let's have a look at the descriptive metadata.

```{r}
wave_attributes <- attributes(harmonized_eb_waves)
wave_attributes$id
wave_attributes$filename
wave_attributes$names
```
Let's review a bit the results:

```{r}
ZA2828 <- pull_survey(eb_waves, id = "ZA2828_trust")
document_survey_item(ZA2828$trust_national_government)
```

## Analyze the data

If you did not save your work to use for another statistical software, from now on you can analyze the harmonized data in R.  The labelled survey data is stored in `labelled_spss_survey()` vectors, which is a complex class that retains much metadata for reproducibility. Most statistical R packages do not know it. The data should be presented either as numeric data with `as_numeric()` or as categorical with `as_factor()`.  (See more why you should not fall back on the more generic `as.factor()` or `as.numeric()` methods in [The labelled_spss_survey class vignette.](http://retroharmonize.satellitereport.com/articles/labelled_spss_survey.html))

If there is a `99901` value, it refers to an invalid observation. The missing value range is not correctly identified. It should be made sure that if there is an unrecognized category label it goes into the missing range (and is marked that it was not recognized.)

```{r factor}
harmonized_eb_waves %>%
  mutate_at ( vars(contains("trust")), as_factor ) %>%
  summary()
```
```{r numericrepr}
numeric_harmonization <- harmonized_eb_waves %>%
  mutate_at ( vars(contains("trust")), as_numeric )
summary(numeric_harmonization)
```

```{r weightednumrepr}
harmonized_eb_waves %>%
  mutate_at ( vars(contains("trust")), as_numeric ) %>%
  mutate_at ( vars(contains("trust")), ~.*weight_poststrat) %>%
  summary()
```

We have a problem: the invalid values should go out to the missing range, but they are not always correctly labelled as missing. The names in the tibble should also be fixed.

```{r}
numeric_harmonization %>%
  group_by(country_id) %>%
  summarize_if ( is.numeric, mean, na.rm=TRUE) 
```
