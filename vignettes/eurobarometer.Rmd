---
title: "Case Study: Working With Eurobarometer"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Case Study: Working With Eurobarometer}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
if ( file.exists("not_included", "daniel_env.R")) {
  source(file.path("not_included", "daniel_env.R"))
} else {
  source(file.path("..", "not_included", "daniel_env.R"))
}

```

In the [Afrobaromter Case Study](http://retroharmonize.satellitereport.com/articles/afrobarometer.html) we have shown how to merge two waves of a survey with a limited number of variables.  This workflow is not feasible with Eurobarometer on a PC or laptop, because there are too many large files to handle. 


```{r setup, message=FALSE}
library(retroharmonize)
library(dplyr)
```

We have created a helper function `subset_save_survey()` that programmatically reads in SPSS files, makes the necessary type conversion to `labelled_spss_survey()` without harmonization, and saves a small, subsetted `rds` file. Because this is a native R file, it is far more efficient to handle in the actual workflow.

```{r subsetting, eval=FALSE}
# To replicate the worklist, you need to have the SPSS file names 
# as a list, and you have to set up your own import and export path.

subset_save_surveys ( 
  survey_list = eb_metadata, 
  selection_name = "trust",
  import_path = gesis_dir, 
  export_path = "working" )

```

```{r, eval=FALSE}
eurobarometer_waves <- file.path("working", dir("working"))
eb_waves <- read_surveys(eurobarometer_waves, .f='read_rds')
```

```{r, eval=FALSE}
if ( dir.exists("working") ) {
  eurobarometer_waves <- file.path("working", dir("working"))
} else { 
  eurobarometer_waves <- file.path("..", "working", dir("working"))
}

eb_waves <- read_surveys(eurobarometer_waves, .f='read_rds')
```

```{r trick-rel-dear, echo=FALSE}
#this should be nicer ....
eurobarometer_waves <- file.path(working_dir, dir(working_dir))
eb_waves <- read_surveys(eurobarometer_waves, .f='read_rds')
```

## Metadata map

Let's analyze the metadata of each survey file. 

```{r metadata}
eb_trust_metadata <- lapply ( X = eb_waves, FUN = metadata_create   )
eb_trust_metadata <- do.call(rbind, eb_trust_metadata)
```

```{r head}
head(eb_trust_metadata)
```

The value labels in this example are not too numerous.  The only variable that stands out is the `Can rely on` and `Cannot rely on` labelled variable. 

```{r all-labels}
valid_labels <- sapply (
  eb_trust_metadata$valid_labels, unlist) %>%
  sapply(., names )
unique(as.character(unlist(valid_labels)))
```
## Harmonize the labels

For easier looping we adopt the `harmonize_values()` function with new default settings. It would be tempting to preserve the `rely` labels, but if we use the same numeric coding, it will lead to confusion. If you want to keep the difference of the two type of category labels, than the harmonization should be done in a two-step process. 

```{r specificfunction}
harmonize_eb_trust <- function(x) {
  label_list <- list(
    from = c("^tend\\snot", "^cannot", 
             "^tend\\sto", "^can\\srely", 
             "^dk", "^decline", "^inap"), 
    to = c("not_trust", "not_trust", "trust", "trust", 
           "do_not_know", "declined", "inap"), 
    numeric_values = c(0,0,1,1,99997,99998,99999)
  )
  
  harmonize_values(x, 
                   harmonize_labels = label_list, 
                   na_values = c("do_not_know"=99997,
                                 "declined"=99998,
                                 "inap"=99999), 
                   na_range = c( 99900, 99999)
  )
}
```

We set a missing range, because we are not sure that all 

Let's see if it works:

```{r, check}
harmonize_eb_trust(eb_waves[[4]]$`trust_european-commission`[1:10])
```
Appears to give the correct results, let's run it through the 9 survey waves. Whenever a variable is missing from a wave, it is filled up with `inapproriate` missing values.

```{r harmonizewaves}
harmonized_eb_waves <- harmonize_waves ( waves = eb_waves, 
                                      .f = harmonize_eb_trust)
```

## Analyze the data

If there is a `99901` value, it refers to an invalid observation. The missing value range is not correctly identified. It should be made sure that if there is an unrecognized category label it goes into the missing range (and is marked that it was not recognized.)

```{r factor}
harmonized_eb_waves %>%
  mutate_at ( vars(contains("trust")), as_factor ) %>%
  summary()
```
```{r numericrepr}
numeric_harmonization <- harmonized_eb_waves %>%
  mutate_at ( vars(contains("trust")), as_numeric ) %>%
  mutate_at ( vars(contains("trust")), ~.*weight_poststrat) 

summary(numeric_harmonization)
```

We have a problem: the invalid values should go out to the missing range, but they are not always correctly labelled as missing. The names in the tibble should also be fixed.

```{r}
numeric_harmonization %>%
  group_by(country_id) %>%
  summarize_if ( is.numeric, mean, na.rm=TRUE) 
```
